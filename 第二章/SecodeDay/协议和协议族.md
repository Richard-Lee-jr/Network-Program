协议和协议族

协议：协议就是为了完成数据交换而定好的约定

协议族

红烧牛肉面和藤椒牛肉面都属于牛肉面的一种。与之类似，套接字通信中的协议也具有以下几类：

|   名称    |        协议族        |
| :-------: | :------------------: |
|  PF_INET  |   IPv4互联网协议族   |
| PF_INET6  |   IPv6互联网协议族   |
| PF_LOCAL  | 本地通信的UNIX协议族 |
| PF_PACKET |   底层套接字协议族   |
|  PF_IPX   |   IPX Novell协议族   |

套接字中实际采用的最终协议信息是通过socket函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数。

套接字类型

套接字类型指的是套接字的数据传输方式，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。

已通过第一个参数传递了协议族信息，为什么还要决定数据传输方式？

问题就在于，决定了协议族并不能同时决定数据传输方式。换言之，socket函数第一个参数PF_INET协议族中也存在多种数据传输方式。

这里最常见的就是面向连接的TCP（SOCK_STREAM）和面向消息的UDP（SOCK_DGRAM）

**面向连接的套接字的特性如下：**

可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字

收发数据的套接字内部有缓冲（buffer），简言之就是字节数组。通过套接字传输的数据将保存到该数组。因此，收到数据并不意味着马上调用recv函数。只有不超过数组容量，则有可能在数据填充满缓冲后通过1次recv函数调用读取缓冲中的全部内容。当然也可以分多次recv调用读取。

也就是说，，在面向连接的套接字中，recv函数和send函数的调用次数并无太大意义。所以说面向连接的套接字并不存在数据边界。

缓冲区满了会发生什么？

首先调用recv函数从缓存区读取部分（或全部）数据，因此，缓冲并不总是满的。

但如果recv函数读取速度比接收数据慢，缓冲就有可能满。此时套接字将无法再接收数据，但即使这样也不会发生数据丢失，因为传输端套接字将停止传输。

也就是说，面向连接的套接字会根据接收端的状态传输数据，如果传输出错还会提供重传服务。因此，面向连接的套接字除特殊情况外不会发生数据丢失。

**面向消息的套接字特性如下：**

①强调快速传输而非传输顺序

②传输的数据可能丢失也可能销毁

③传输的数据有数据边界

④限制每次传输的数据大小

即面向消息的套接字比面向连接的套接字具有更快的传输速度，但无法避免数据丢失或损毁。另外，每次传输的数据大小具有一定限制，并存在数据边界。存在数据边界意味着接收数据的次数应和传输次数相同。面向消息的套接字特性总结如下：

不可靠的、不按序传递的、以数据的高速传输为目的的套接字。

**协议的最终选择**

socket函数的第三个参数决定最终采用的协议。

前面已经通过socket函数的前两个参数传递了协议族信息和数据传输方式，这些信息还不足以决定采用的协议吗？为什么还需要传递第三个参数？

正如各位所想，传递前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递0，除非遇到以下这种情况：

同一协议族中存在多个数据传输方式相同的协议。

协议族相同、传输方式也相同，但协议不同。此时就需要通过第三个参数具体指定协议信息。

这里以PF_INET为例，PF_INET指IPv4网络协议族，SOCK_STREAM是面向连接的数据传输。满足这两个条件的只有IPPROTO_TCP，因此可以省略第三个参数创建面向连接的套接字：

```c++
int tcp_socket = socket(PF_INET, SOCK_STREAM, 0);
//或
int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)
```

SOCK_DGRAM指的是面向消息的数据传输方式，满足上述条件的协议只有IPPROTO_UDP。因此可以通过以下方式创建面向消息的套接字：

```C++
int udp_socket = socket(PF_INET, SOCK_DGRAM, 0);
//或
int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
```