## 套接字类型

监听套接字：服务器端创建的套接字称为服务器端套接字或监听套接字。

连接套接字：主动连接的套接字

## 进入等待连接请求状态

调用bind函数给套接字分配了地址后就要调用listen函数进入等待连接请求状态。

只有调用了listen函数，客户端才能进入可发出连接请求的状态，即客户端才能调用connect函数（若提前调用将会发生错误），这就是之前强调要先启动服务器端程序的原因了。

```c++
int listen(SOCKET s, int backlog);
//s : 希望进入等待连接请求状态的套接字句柄，传递的是服务器端的套接字句柄（监听套接字）
//backlog : 连接请求等待队列的长度，若为5，表示最多使5个连接请求进入队列
//返回值：成功返回0，失败返回SOCKET_ERROR
```

服务器处于等待连接请求状态是指：客户端请求连接时，受理连接（服务器端调用accept）前一直使连接处于等待状态，如图：

## 受理客户端连接请求

调用listen函数后，若有新的连接请求，则应按序受理。

受理连接一位置进入可接受数据的状态，因此需要套接字，可以使用服务器端的监听套接字吗？

如果用服务器端的监听套接字进行I/O，那么等待请求连接队列外就无人守门了，即所有客户端的请求连接都会进入连接请求等待队列了。

因此需要另外一个套接字，但没必要亲自创建，accept函数会自动创建套接字并连接到发起请求的客户端。

```C++
SOCKET accept(SOCKET s, struct SOCKADDR* addr, int len);
//s : 服务器套接字的文件描述符
//addr : 保存发起连接的客户端地址信息的变量地址值，调用函数后向传递来的变量参数填充客户端地址信息
//len : 第二个参数addr结构体的长度，但是存有长度的变量地址。函数调用完成后，该变量即被填入客户端地址长度
//返回值：成功时返回创建的套接字句柄（连接套接字），失败时返回INVALID_SOCKET
```

accept函数受理连接请求等待队列中待处理的客户端连接请求，函数调用成功时，accept内部将产生用于数据IO的套接字，并返回其句柄。

需要强调的是，套接字是自动创建的，并自动与发起连接请求的客户端建立连接。

如图：

